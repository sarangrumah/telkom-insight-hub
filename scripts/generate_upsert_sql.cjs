const { Pool } = require('pg');
const fs = require('fs');
const path = require('path');
require('dotenv').config();

const connectionString = process.env.DATABASE_URL;

if (!connectionString) {
  console.error('DATABASE_URL is not defined in .env');
  process.exit(1);
}

const pool = new Pool({
  connectionString,
  ssl: process.env.DATABASE_SSL === 'true' ? { rejectUnauthorized: false } : false,
});

function parsePgArray(val) {
  if (!val) return [];
  if (Array.isArray(val)) return val;
  if (typeof val === 'string') {
    // Remove braces
    const content = val.substring(1, val.length - 1);
    if (!content) return [];
    // Split by comma, handling quotes if necessary (simple split for column names usually works unless they contain commas)
    return content.split(',').map(s => s.trim().replace(/^"|"$/g, ''));
  }
  return [];
}

function formatValue(val) {
  if (val === null || val === undefined) return 'NULL';
  
  if (typeof val === 'boolean') return val ? 'TRUE' : 'FALSE';
  
  if (typeof val === 'number') return val;
  
  if (val instanceof Date) {
    return `'${val.toISOString()}'`;
  }
  
  if (Array.isArray(val)) {
    // Handle arrays (e.g. text[])
    // Simple implementation for string arrays
    // Postgres array format: '{"val1", "val2"}'
    const arrayContent = val.map(v => {
        if (v === null) return 'NULL';
        if (typeof v === 'string') return `"${v.replace(/"/g, '\\"')}"`;
        return v;
    }).join(',');
    return `'{${arrayContent}}'`;
  }

  if (typeof val === 'object') {
    return `'${JSON.stringify(val).replace(/'/g, "''")}'`;
  }

  if (typeof val === 'string') {
    return `'${val.replace(/'/g, "''")}'`;
  }

  return `'${String(val).replace(/'/g, "''")}'`;
}

async function generateSyncSql() {
  const client = await pool.connect();
  try {
    // Get PKs using pg_constraint
    const pksRes = await client.query(`
      SELECT
        n.nspname AS table_schema,
        c.relname AS table_name,
        array_agg(a.attname ORDER BY array_position(con.conkey, a.attnum)) AS pk_columns
      FROM pg_constraint con
      JOIN pg_class c ON c.oid = con.conrelid
      JOIN pg_namespace n ON n.oid = c.relnamespace
      JOIN pg_attribute a ON a.attrelid = c.oid AND a.attnum = ANY(con.conkey)
      WHERE con.contype = 'p'
      AND n.nspname IN ('public', 'auth', 'storage', 'realtime')
      GROUP BY n.nspname, c.relname;
    `);
    
    const pkMap = {};
    pksRes.rows.forEach(row => {
      pkMap[`${row.table_schema}.${row.table_name}`] = parsePgArray(row.pk_columns);
    });

    // Get tables
    const tablesRes = await client.query(`
      SELECT table_schema, table_name
      FROM information_schema.tables
      WHERE table_schema IN ('public', 'auth', 'storage', 'realtime')
      AND table_type = 'BASE TABLE'
      ORDER BY table_schema, table_name
    `);

    const tables = tablesRes.rows;
    let sqlOutput = '-- Data Sync Script generated by generate_upsert_sql.cjs\n\n';

    for (const table of tables) {
      const { table_schema, table_name } = table;
      const pk_columns = pkMap[`${table_schema}.${table_name}`];
      const fullTableName = `"${table_schema}"."${table_name}"`;
      
      console.log(`Processing ${fullTableName}...`);

      // Get all columns
      const columnsRes = await client.query(`
        SELECT column_name, data_type, udt_name
        FROM information_schema.columns
        WHERE table_schema = $1 AND table_name = $2
        ORDER BY ordinal_position
      `, [table_schema, table_name]);

      const columns = columnsRes.rows.map(c => c.column_name);
      
      let pks = pk_columns;
      if ((!pks || pks.length === 0) && columns.includes('id')) {
          pks = ['id'];
      }

      // Fetch data
      const dataRes = await client.query(`SELECT * FROM ${fullTableName}`);
      const rows = dataRes.rows;

      if (rows.length === 0) continue;

      sqlOutput += `\n-- Data for ${fullTableName}\n`;
      sqlOutput += `TRUNCATE TABLE ${fullTableName} CASCADE;\n`;

      for (const row of rows) {
        const colNames = columns.map(c => `"${c}"`).join(', ');
        const values = columns.map(c => formatValue(row[c])).join(', ');

        let insertStmt = `INSERT INTO ${fullTableName} (${colNames}) VALUES (${values})`;

        if (Array.isArray(pks) && pks.length > 0 && pks[0] !== null) {
          const updateSet = columns
            .filter(c => !pks.includes(c))
            .map(c => `"${c}" = EXCLUDED."${c}"`)
            .join(', ');

          if (updateSet) {
            insertStmt += ` ON CONFLICT ("${pks.join('", "')}") DO UPDATE SET ${updateSet};`;
          } else {
            insertStmt += ` ON CONFLICT ("${pks.join('", "')}") DO NOTHING;`;
          }
        } else {
          // No PK, just insert (might duplicate)
          insertStmt += ';';
        }

        sqlOutput += insertStmt + '\n';
      }
    }

    fs.writeFileSync('sync_data.sql', sqlOutput);
    console.log('Sync SQL generated in sync_data.sql');

  } catch (err) {
    console.error('Error generating sync SQL:', err);
  } finally {
    client.release();
    await pool.end();
  }
}

generateSyncSql();
